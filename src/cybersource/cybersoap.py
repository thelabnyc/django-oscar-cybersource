from __future__ import annotations

from decimal import Decimal
from typing import TYPE_CHECKING, Any
import logging

from cryptography.hazmat.primitives.serialization import (
    Encoding,
    NoEncryption,
    PrivateFormat,
)
from cryptography.hazmat.primitives.serialization.pkcs12 import (
    PKCS12KeyAndCertificates,
    load_pkcs12,
)
from django.dispatch import Signal
from django.http import HttpRequest
from django.utils.functional import cached_property
from zeep.client import Factory
from zeep.transports import Transport
from zeep.wsse import BinarySignature, MemorySignature
import xmlsec
import zeep
import zeep.cache

from . import signals
from .constants import CHECKOUT_FINGERPRINT_SESSION_ID, PRECISION, TERMINAL_DESCRIPTOR

if TYPE_CHECKING:
    from oscar.apps.order.models import Order

logger = logging.getLogger(__name__)


type SoapRequest = dict[str, Any]
type SoapResponse = Any


class BinaryMemorySignature(BinarySignature):
    """
    Same as `zeep.wsse.BinarySignature`, but uses keys from memory, rather than
    reading them from files on disk.
    """

    def __init__(
        self,
        key_data: bytes,
        cert_data: bytes,
        password: bytes | None = None,
        signature_method: str | None = None,
        digest_method: str | None = None,
    ) -> None:
        MemorySignature.__init__(
            self,
            key_data=key_data,
            cert_data=cert_data,
            password=password,
            signature_method=signature_method,
            digest_method=digest_method,
        )

    def verify(self, envelope: Any) -> None:
        """Disable verification since Cybersource doesn't sign responses"""
        pass


class CyberSourceSoap:
    """
    Wrapper around the Cybersource SOAP API.

    The given WSDL should be one of the following:

    - Test Environments: ``https://ics2wstesta.ic3.com/commerce/1.x/transactionProcessor/CyberSourceTransaction_1.141.wsdl``
    - Production Environments: ``https://ics2wsa.ic3.com/commerce/1.x/transactionProcessor/CyberSourceTransaction_1.141.wsdl``

    MerchantID should be your Cybersource account's merchant ID. PKCS12
    data/password should be the contents of the `.p12` file and it's associated
    password. This is generated by creating a "REST Certificate" type key. in
    the Cybersource Business Center. Treat this like a password and do not check
    it into version control.
    """

    wsdl: str
    merchant_id: str
    pkcs12: PKCS12KeyAndCertificates
    order: Order
    request: HttpRequest | None
    method_key: str | None
    wsdl_cache: zeep.cache.Base

    def __init__(
        self,
        wsdl: str,
        merchant_id: str,
        pkcs12_data: bytes,
        pkcs12_password: bytes,
        order: Order,
        request: HttpRequest | None = None,
        method_key: str | None = "",
        wsdl_cache: zeep.cache.Base | None = None,
    ):
        self.wsdl = wsdl
        self.merchant_id = merchant_id
        self.pkcs12 = load_pkcs12(pkcs12_data, pkcs12_password)
        self.order = order
        self.request = request
        self.method_key = method_key
        self.wsdl_cache = wsdl_cache or zeep.cache.InMemoryCache()

    @property
    def client_settings(self) -> zeep.Settings:
        settings = zeep.Settings()
        return settings

    @property
    def client_wsse(self) -> MemorySignature:
        # Decrypt the pkcs12 data using the given password, then extract the
        # private key and certificate into PEMs.
        if self.pkcs12.key is None:
            raise ValueError("pkcs12 data does not contain a valid private key")
        if self.pkcs12.cert is None:
            raise ValueError("pkcs12 data does not contain a valid certificate")
        privkey_pem = self.pkcs12.key.private_bytes(
            encoding=Encoding.PEM,
            format=PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=NoEncryption(),
        )
        cert_pem = self.pkcs12.cert.certificate.public_bytes(
            encoding=Encoding.PEM,
        )
        wsse = BinaryMemorySignature(
            key_data=privkey_pem,
            cert_data=cert_pem,
            signature_method=xmlsec.Transform.RSA_SHA256,  # type:ignore[attr-defined]
            digest_method=xmlsec.Transform.SHA256,  # type:ignore[attr-defined]
        )
        return wsse

    @cached_property
    def client(self) -> zeep.Client:
        """
        Construct and return a zeep SOAP client
        """
        client = zeep.Client(
            wsdl=self.wsdl,
            settings=self.client_settings,
            wsse=self.client_wsse,
            transport=Transport(cache=self.wsdl_cache),
        )
        return client

    @cached_property
    def factory(self) -> Factory:
        return self.client.type_factory("ns0")

    def run_advanced_fraud_screen(self) -> SoapResponse:
        """
        Screen the order data for signs of possible fraud
        """
        txndata = self._prep_transaction(
            amount=self.order.total_incl_tax,
            afsService=self.factory.AFSService(run="true"),
        )
        return self._run_transaction(txndata)

    def get_token(self, encrypted_payment_data: str) -> SoapResponse:
        """
        Get a token using encrypted card number
        """
        txndata = self._prep_transaction(
            amount="0",
            paySubscriptionCreateService=self.factory.PaySubscriptionCreateService(
                run="true",
            ),
            encryptedPayment=self.factory.EncryptedPayment(
                data=encrypted_payment_data,
                descriptor=TERMINAL_DESCRIPTOR,
            ),
            recurringSubscriptionInfo=self.factory.RecurringSubscriptionInfo(
                frequency="on-demand"
            ),
        )
        # Add extra fields
        self._trigger_pre_build_hook(
            txndata=txndata,
            signal=signals.pre_build_get_token_request,
        )
        # Run transaction
        return self._run_transaction(txndata)

    def lookup_payment_token(self, token: str) -> SoapResponse:
        """
        Using a payment token, lookup some of the details about the related card
        """
        txndata = self._prep_transaction(
            amount="0",
            paySubscriptionRetrieveService=self.factory.PaySubscriptionRetrieveService(
                run="true",
            ),
            recurringSubscriptionInfo=self.factory.RecurringSubscriptionInfo(
                subscriptionID=token,
            ),
        )
        # Run transaction
        return self._run_transaction(txndata)

    def authorize(self, token: str, amount: Decimal) -> SoapResponse:
        """
        Authorize with a payment token
        """
        txndata = self._prep_transaction(
            amount=amount,
            ccAuthService=self.factory.CCAuthService(run="true"),
            recurringSubscriptionInfo=self.factory.RecurringSubscriptionInfo(
                subscriptionID=token,
            ),
        )
        # Add extra fields
        self._trigger_pre_build_hook(
            txndata=txndata,
            signal=signals.pre_build_auth_request,
            token=token,
        )
        # Run transaction
        return self._run_transaction(txndata)

    def capture(
        self,
        token: str,
        amount: Decimal,
        auth_request_id: str,
    ) -> SoapResponse:
        """
        Authorize with a payment token
        """
        txndata = self._prep_transaction(
            amount=amount,
            ccCaptureService=self.factory.CCCaptureService(
                run="true",
                authRequestID=auth_request_id,
            ),
            recurringSubscriptionInfo=self.factory.RecurringSubscriptionInfo(
                subscriptionID=token,
            ),
        )
        # Add extra fields
        self._trigger_pre_build_hook(
            txndata=txndata,
            signal=signals.pre_build_capture_request,
            token=token,
        )
        # Run transaction
        return self._run_transaction(txndata)

    def _prep_transaction(
        self,
        amount: Decimal | str,
        **kwargs: Any,
    ) -> SoapRequest:
        data: SoapRequest = {} | kwargs

        # Add merchant info
        if self.request and CHECKOUT_FINGERPRINT_SESSION_ID:
            fingerprint_id = self.request.session.get(CHECKOUT_FINGERPRINT_SESSION_ID)
            if fingerprint_id:
                data["deviceFingerprintID"] = fingerprint_id

        data["merchantID"] = self.merchant_id
        data["merchantReferenceCode"] = self.order.number

        # Add order info
        data["billTo"] = self.factory.BillTo(email=self.order.email)
        if self.request:
            data["billTo"].ipAddress = self.request.META.get("REMOTE_ADDR")
        if self.order.user:
            data["billTo"].customerID = self.order.user.pk

        # Add order billing data
        if self.order.billing_address:
            data["billTo"].firstName = self.order.billing_address.first_name
            data["billTo"].lastName = self.order.billing_address.last_name
            data["billTo"].street1 = self.order.billing_address.line1
            data["billTo"].street2 = self.order.billing_address.line2
            data["billTo"].city = self.order.billing_address.line4
            data["billTo"].state = self.order.billing_address.state
            data["billTo"].postalCode = self.order.billing_address.postcode
            data["billTo"].country = self.order.billing_address.country.iso_3166_1_a2

        # Add order shipping data
        if self.order.shipping_address:
            data["shipTo"] = self.factory.ShipTo(
                phoneNumber=self.order.shipping_address.phone_number,
                firstName=self.order.shipping_address.first_name,
                lastName=self.order.shipping_address.last_name,
                street1=self.order.shipping_address.line1,
                street2=self.order.shipping_address.line2,
                city=self.order.shipping_address.line4,
                state=self.order.shipping_address.state,
                postalCode=self.order.shipping_address.postcode,
                country=self.order.shipping_address.country.iso_3166_1_a2,
            )

        # Add line items
        data["item"] = [
            self.factory.Item(
                id=str(i),
                productName=line.product.title if line.product is not None else "",
                productSKU=line.partner_sku,
                quantity=str(line.quantity),
                unitPrice=str(
                    line.unit_price_incl_tax.quantize(PRECISION)
                    if line.unit_price_incl_tax is not None
                    else ""
                ),
            )
            for i, line in enumerate(self.order.lines.all())
        ]

        # Add order total data
        data["purchaseTotals"] = self.factory.PurchaseTotals(
            currency=self.order.currency,
            grandTotalAmount=amount if amount is not None else "0",
        )

        # Prep is done
        return data

    def _trigger_pre_build_hook(
        self,
        txndata: SoapRequest,
        signal: Signal,
        token: str | None = None,
    ) -> None:
        """
        Send a Django signal as a means of allowing applications to modify the
        merchantDefinedData fields in the transaction before we run it.
        """
        extra_fields: dict[str, Any] = {}
        signal.send(
            sender=self.__class__,
            extra_fields=extra_fields,
            request=self.request,
            order=self.order,
            token=token,
            method_key=self.method_key,
        )
        mdata = self.factory.MerchantDefinedData()
        for k, v in extra_fields.items():
            field_name = f"field{k}"
            setattr(mdata, field_name, v)
        txndata["merchantDefinedData"] = mdata

    def _run_transaction(self, txndata: SoapRequest) -> SoapResponse:
        """
        Send the transaction to Cybersource to process
        """
        try:
            response = self.client.service.runTransaction(**txndata)
        except Exception:
            logger.exception(
                "Failed to run Cybersource SOAP transaction on Order {}".format(
                    self.order.number
                )
            )
            response = None
        return response
